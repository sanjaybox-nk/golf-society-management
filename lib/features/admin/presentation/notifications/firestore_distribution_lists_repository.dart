import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../../models/distribution_list.dart';
import 'distribution_lists_repository.dart';

class FirestoreDistributionListsRepository implements DistributionListsRepository {
  final FirebaseFirestore _firestore;

  FirestoreDistributionListsRepository(this._firestore);

  @override
  Stream<List<DistributionList>> watchLists() {
    return _firestore
        .collection('distribution_lists')
        .orderBy('name')
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data();
        data['id'] = doc.id; // Ensure ID matches doc ID
        
        // Handle Timestamp conversion if necessary (though Freezed handles DateTime usually, Firestore returns Timestamp)
        if (data['createdAt'] is Timestamp) {
            data['createdAt'] = (data['createdAt'] as Timestamp).toDate().toIso8601String();
        }

        return DistributionList.fromJson(data);
      }).toList();
    });
  }

  @override
  Future<void> createList(DistributionList list) async {
    // Let Firestore generate the ID or use the one provided if unique strategy needed.
    // Ideally, for create, we might want Firestore to gen the ID, but our model requires one.
    // If list.id is a temp ID, we can ignore it and let Firestore gen one, then update?
    // Or we stick to the provided ID if we generated a UUID beforehand.
    // Let's assume the ID passed in is a valid UUID or timestamp string generated by client.
    
    // Convert to JSON and ensure timestamp is handled
    final json = list.toJson();
    json.remove('id'); // Don't save ID inside the doc if using doc ID, but model expects it.
    // Actually, usually we save it or map it. Let's rely on mapping doc.id back to 'id' on read.
    // But for writes, we can just write the fields.
    
    // Ensure DateTime is Timestamp for Firestore or string. 
    // Freezed toJson produces String for DateTime usually. 
    // Ideally we want server timestamp or just store the string. 
    // Let's stick to what toJson gives us for now, or convert to Timestamp if we want native querying.
    // For simplicitly with Freezed, storing as String/Map is fine, but sorting by date might suffer if string format isn't standard.
    // The model uses DateTime, Freezed usually serializes to ISO string.
    
    await _firestore.collection('distribution_lists').doc(list.id).set(json);
  }

  @override
  Future<void> updateList(DistributionList list) async {
    final json = list.toJson();
    json.remove('id');
    await _firestore.collection('distribution_lists').doc(list.id).update(json);
  }

  @override
  Future<void> deleteList(String listId) async {
    await _firestore.collection('distribution_lists').doc(listId).delete();
  }
}

final distributionListsRepositoryProvider = Provider<DistributionListsRepository>((ref) {
  return FirestoreDistributionListsRepository(FirebaseFirestore.instance);
});
